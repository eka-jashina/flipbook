# Ревью бэкенда Flipbook — взгляд опытного бэкенд-разработчика

> Дата: 2026-03-01
> Проанализирован: `server/` — Express 5 + Prisma + PostgreSQL + S3

---

## Общая оценка: 8.2 / 10

Это **зрелый, production-ready бэкенд** с продуманной архитектурой, хорошей безопасностью и приличным покрытием тестами. Проект значительно выше среднего для персонального/pet-проекта и сопоставим с коммерческими MVP.

---

## 1. Архитектура и структура проекта

### Что хорошо (сильные стороны)

**Чёткое послойное разделение:**
```
routes/ → services/ → utils/prisma.ts → PostgreSQL
                    → utils/storage.ts → S3
middleware/ (сквозные аспекты: auth, CSRF, validation, rate limiting, upload, ownership)
```

Каждый слой имеет ясную ответственность. Роуты — тонкие (вызов validate + asyncHandler + вызов сервиса + ответ). Бизнес-логика сосредоточена в сервисах. Утилиты — чистые функции и инфраструктурные обёртки. Это каноническая архитектура для Express-приложений, легко масштабируемая и понятная новому разработчику.

**13 ресурсных групп** с полным CRUD покрытием: books, chapters, appearance, sounds, ambients, decorativeFont, defaultSettings, fonts, settings, progress, upload, export/import, auth. Каждый ресурс — отдельный файл роутов и сервис. Единая конвенция именования: `*.routes.ts` + `*.service.ts`.

**Типобезопасность:** TypeScript покрывает весь бэкенд. DTO-маппинг (`mappers.ts`) явно отделяет внутренние модели Prisma от API-ответов — passwordHash никогда не утекает. Типы API (`types/api.ts`) создают единый контракт.

**Конфигурация через Zod** (`config.ts`) — все переменные окружения валидируются при старте с чёткими сообщениями об ошибках. Разделение dev/production дефолтов (S3 креды, CORS, secure cookies).

### Что можно улучшить

**Нет явного слоя репозиториев.** Сервисы напрямую вызывают `getPrisma()`. Это работает при текущем размере, но при росте проекта замена Prisma или юнит-тестирование бизнес-логики без БД станет затруднительной. Внедрение тонкого Repository-интерфейса повысило бы тестируемость.

**Singleton-паттерн для Prisma и S3** через мутабельные переменные модуля (`let prisma: PrismaClient | null = null`). Работает, но делает юнит-тестирование сложнее — нельзя подменить зависимость без monkey-patching. В идеале — DI-контейнер или фабрика, передающая зависимости вниз.

**Нет разделения на bounded contexts.** Все 13 ресурсов живут в одном плоском пространстве. Пока это не проблема, но при росте (например, добавление комментариев, социальных фич, аналитики) стоит группировать по доменам.

---

## 2. Безопасность

### Что хорошо — и это впечатляет

Безопасность — одна из самых сильных сторон проекта. Видно, что автор хорошо знаком с OWASP и типичными атаками.

**Аутентификация:**
- Bcrypt с 12 раундами (файл `password.ts`) — отличный выбор.
- Session regeneration после login/register/OAuth (`auth.routes.ts:26-39`) — предотвращает session fixation.
- Passport с local + Google OAuth стратегиями.
- Защита от account pre-hijacking: Google OAuth не связывается с аккаунтами, у которых уже есть пароль (`auth.ts:151-158`). Это продуманный и нетривиальный кейс.

**CSRF:**
- Double-submit cookie pattern через `csrf-csrf` (`csrf.ts`), привязка к sessionID.
- Отдельный эндпоинт `/api/auth/csrf-token` для SPA.

**Password Reset:**
- 32 байта криптографического рандома, хэш SHA-256 для хранения (правильно — токен уже случайный, bcrypt избыточен).
- Атомарный `updateMany` с WHERE по хэшу токена — предотвращает race condition при concurrent reset (`auth.service.ts:170-182`).
- Инвалидация всех сессий после сброса через raw SQL по JSON-полю `passport.user` в таблице sessions.
- Защита от email enumeration — forgot-password всегда возвращает 200.

**Input validation:**
- Zod-схемы на всех эндпоинтах (`schemas.ts`).
- `isSafeUrl()` блокирует `javascript:`, `vbscript:`, `data:` (кроме `data:font/`) — защита от URI-scheme атак.
- Лимиты на размер тела запроса: 256 KB по умолчанию, 3 MB для глав, 10 MB для импорта.

**XSS:**
- DOMPurify через JSDOM на сервере (`sanitize.ts`) — санитизация HTML глав при создании И обновлении.
- Явный whitelist тегов и атрибутов, `ALLOW_DATA_ATTR: false`.

**SQL Injection:**
- Prisma параметризует все запросы.
- Даже raw SQL в `reorder.ts` использует `Prisma.sql` tagged templates.
- `bulkUpdatePositions` проверяет таблицу по whitelist перед формированием запроса.

**Rate limiting:**
- 3 уровня: общий (100/мин), auth (5/мин), public (30/мин).
- Корректно отключен в тестах.

**Helmet** + `security_opt: no-new-privileges` в Docker.

### Замечания по безопасности

**Несогласованность ownership-проверок — главная проблема.**

В `app.ts:163` видна централизованная проверка:
```typescript
app.use('/api/books/:bookId', requireAuth, requireBookOwnership);
```

Это покрывает все под-ресурсы книг через middleware. **Однако** роуты books.routes.ts дополнительно навешивают `requireBookOwnership` на каждый эндпоинт с `:bookId` — что приводит к **двойному вызову** `verifyBookOwnership` для одного запроса (одна проверка на уровне app.use, вторая — в роуте). Это не баг, но лишний запрос к БД на каждый запрос к книге.

**Рекомендация:** Убрать дублирующий `requireBookOwnership` из отдельных роутов в `books.routes.ts`, раз он уже установлен глобально в `app.ts`.

**MIME-type валидация загрузок полагается на клиентский Content-Type.** `application/octet-stream` разрешён в font и book uploads — это позволяет обойти проверку типа. Для продакшена стоит добавить проверку magic bytes (файловых сигнатур).

**Нет ограничения на количество сессий на пользователя.** Злоумышленник с валидными кредами может создать неограниченное количество сессий, заполняя таблицу session. Стоит либо лимитировать, либо добавить cleanup.

**Нет Content-Security-Policy на API-ответы.** Helmet устанавливает заголовки, но для Swagger UI CSP задан inline в HTML (`swagger.ts:277`). Стоит убедиться, что helmet не конфликтует с этим.

---

## 3. Работа с базой данных

### Что хорошо

**Prisma-схема спроектирована грамотно:**
- UUID v4 как первичные ключи (`gen_random_uuid()`) — нет sequential ID enumeration.
- Каскадное удаление на всех FK — удаление книги автоматически чистит главы, ambient'ы, настройки.
- Составные индексы: `@@index([userId, position])` для сортированных списков, `@@unique([userId, bookId])` для reading progress.
- Чёткий маппинг между camelCase (JS) и snake_case (DB) через `@map`.
- `@db.Timestamptz()` для дат — корректная обработка часовых поясов.

**Serializable transactions с retry** (`serializable.ts`) для позиционных операций — правильный подход к race conditions при создании элементов с автоинкрементом position.

**Bulk reorder** через один SQL UPDATE с CASE WHEN (`reorder.ts`) — эффективнее, чем N отдельных UPDATE.

**Ограничения ресурсов** (`limits.ts`): 100 книг/пользователь, 200 глав/книга, 50 шрифтов, 20 ambient'ов — предотвращает resource exhaustion.

### Замечания

**Нет soft delete.** Удаление книги — необратимая операция. Для production-системы стоит рассмотреть `deletedAt` поле и архивацию.

**Нет оптимистичной блокировки на обычных update'ах.** Если два пользователя одновременно редактируют главу, последний перезапишет. `updatedAt` есть, но не используется для конфликт-детекции. Для этого проекта это допустимо, но стоит учитывать при росте.

**ReadingProgress хранит настройки (font, fontSize, theme и т.д.)** помимо позиции чтения. Это нарушает Single Responsibility — progress и preferences смешаны в одной таблице. При расширении модели (закладки, аннотации) станет неудобно.

**Нет миграции вниз (down migrations).** Prisma миграции — только вперёд. Для production deploy стоит иметь план отката.

**Нет connection pooling конфигурации.** PrismaClient использует дефолтный пул. Для нагруженного приложения стоит настроить `connection_limit`, `pool_timeout` в DATABASE_URL или через Prisma config.

---

## 4. API Design

### Что хорошо

**RESTful конвенции соблюдаются:**
- `GET /api/books` — список, `POST /api/books` — создание.
- `GET /api/books/:id` — детали, `PATCH /api/books/:id` — частичное обновление, `DELETE` — удаление.
- Вложенные ресурсы: `/api/books/:bookId/chapters`.
- `PATCH /reorder` — именованная операция для массового обновления позиций.
- 201 для создания, 204 для удаления, 200 для остального.

**Единый формат ответов** через `ok()` и `created()` хелперы:
```json
{ "data": { ... }, "meta": { ... } }
```

**Пагинация:** `limit/offset` для списка книг с `total` в ответе.

**OpenAPI/Swagger** автогенерируется из Zod-схем через кастомный `zodToOpenApi()` конвертер — документация всегда синхронизирована с валидацией.

### Замечания

**Нет версионирования API** (`/api/v1/...`). При изменении контракта придётся ломать клиентов или городить хаки.

**Пагинация только для книг.** Остальные списки (chapters, ambients, fonts) возвращаются полностью. При 200 главах с htmlContent это может быть проблемой. Впрочем, `getChapters()` не возвращает htmlContent — только метаданные. Это правильно.

**PATCH для reorder** — спорный выбор. Семантически это скорее action, не частичное обновление ресурса. `POST /api/books/reorder` был бы яснее. Но это вкусовщина.

**Нет ETag/If-Match для кэширования и конкурентных обновлений.** Для e-book reader'а с offline-режимом это было бы особенно полезно.

**Health check** (`app.ts:116-148`) — грамотный, проверяет и DB, и S3, возвращает degraded вместо ошибки. Единственное замечание — health-эндпоинт не защищён от спама (не за rate limiter'ом).

---

## 5. Обработка ошибок

### Что хорошо — эталонная реализация

**Централизованный error handler** (`errorHandler.ts`) обрабатывает все типы ошибок:
- `AppError` — кастомные бизнес-ошибки с кодом и деталями.
- `ZodError` — ошибки валидации с подробностями (path, message).
- `MulterError` — ошибки загрузки (413 для размера, 400 для типа).
- `PrismaClientKnownRequestError` — P2002 (409, без утечки имён полей), P2025 (404), P2003 (409).
- Ошибки CSRF — проброс statusCode.
- Неизвестные ошибки — 500 с generic message, детальный лог.

**Security logging:** 401, 403, 429 логируются как warn для мониторинга.

**RequestId** в каждом ответе об ошибке — позволяет трейсить проблему в логах.

**Утечки внутренней информации нет:** Prisma error codes, имена полей, stack traces — не попадают в ответ.

**asyncHandler** (`asyncHandler.ts`) — элегантный паттерн, устраняющий try/catch бойлерплейт. Работает корректно.

### Замечания

**Нет различия между клиентскими и серверными ошибками в формате ответа.** И 400, и 500 имеют одинаковую структуру `{ error, message, statusCode }`. Это скорее преимущество (единообразие), но некоторые команды предпочитают разные форматы.

**Нет retry-логики для transient DB errors** (connection timeout, pool exhaustion). Serializable retry обрабатывает только P2034. Стоит добавить обработку connection errors.

---

## 6. Тестирование

### Что хорошо

**~99 тест-кейсов** покрывают все 14 endpoint-групп. Тесты через supertest проверяют реальный HTTP-стек (middleware → route → service → DB).

**Тестовая инфраструктура грамотная:**
- `cleanDatabase()` чистит в правильном FK-порядке.
- `createAuthenticatedAgent()` создаёт сессию + CSRF одним вызовом.
- `wrapAgentWithCsrf()` автоматически добавляет CSRF-хедер к мутирующим запросам.

**Что тестируется:**
- CRUD операции — happy path.
- Auth: регистрация, логин, дубликат email, слабые пароли.
- Ownership: доступ к чужим ресурсам → 403.
- CSRF: мутация без токена → 403.
- Валидация: некорректные данные → 400 с деталями.
- Лимиты ресурсов.
- Export/Import — полный цикл.
- File parsing (txt, fb2).

### Замечания — важные

**Нет юнит-тестов сервисов.** Все тесты — интеграционные через HTTP. Сервисная логика (sanitization, position calculation, S3 cleanup) не тестируется изолированно. При росте проекта это станет узким местом — интеграционные тесты медленные.

**Нет тестов на конкурентность.** Serializable retry — ключевой механизм, но ни один тест не создаёт race condition. Стоит добавить тесты с параллельными запросами на создание элементов с position.

**Нет тестов на edge cases парсеров.** Upload-тесты проверяют txt и fb2, но не docx, epub, doc. Учитывая сложность этих парсеров (особенно DOC с OLE2), это серьёзный пробел.

**Нет нагрузочных тестов.** Для проекта с rate limiting и connection pooling это было бы полезно.

**Coverage неизвестен.** Нет настроенного coverage-отчёта для серверных тестов (в package.json нет `test:coverage`).

**`fileParallelism: false`** в конфиге vitest — тесты идут последовательно. Правильно для консистентности БД, но замедляет CI.

---

## 7. Парсеры книг

### Что хорошо

5 форматов (TXT, DOC, DOCX, EPUB, FB2) — впечатляющий набор. Каждый парсер возвращает унифицированный `ParsedBook { title, author, chapters[] }`.

**DOC-парсер** (`DocParser.ts`) — реализация парсинга OLE2 формата с нуля (Piece Table, FAT navigation, CP1252 mapping). Это сложная и качественная работа.

**EPUB-парсер** корректно обрабатывает OPF metadata, spine order, image embedding (base64 data URLs).

**FB2-парсер** поддерживает рекурсивный парсинг секций, embedded images, стихи, эпиграфы.

### Замечания

**Нет ограничения на размер распарсенных данных.** Файл 50 MB после парсинга может сгенерировать HTML, значительно превышающий лимиты. Стоит добавить проверку размера выходных данных.

**Парсеры не обрабатывают malformed-файлы gracefully.** Некорректный EPUB или DOC может вызвать uncaught exception. Стоит обернуть каждый парсер в try/catch с понятным сообщением.

**Нет timeout на парсинг.** Сложный DOC-файл может парситься долго, блокируя event loop. Стоит добавить timeout или вынести в worker thread.

---

## 8. Инфраструктура и DevOps

### Что хорошо

**Docker Compose** — полный стек (PostgreSQL 17, MinIO, server) с healthcheck'ами и `service_healthy` условиями. `minio-init` контейнер для автоматического создания bucket'а — правильный подход.

**Dockerfile** — multi-stage build (frontend → backend → production). Alpine-базы, dumb-init для PID 1, non-root user (`appuser`), HEALTHCHECK, `npm ci --omit=dev` + cache clean.

**Graceful shutdown** (`index.ts:32-51`) — обработка SIGTERM/SIGINT с 10-секундным таймаутом, `.unref()` на таймере. `unhandledRejection` и `uncaughtException` логируются.

**Sentry** — опциональная интеграция для мониторинга ошибок в production.

**Pino** для логирования — structured JSON в production, pretty-print в development, silent в тестах.

### Замечания

**Нет CI/CD для бэкенда.** GitHub Actions (описан в CLAUDE.md) запускает только фронтенд-тесты. Серверные тесты не включены в CI-pipeline. Это критично — без CI нет гарантии, что сервер работает после изменений.

**Docker Compose использует dev-секреты в environment:** `SESSION_SECRET: dev-session-secret-change-in-production-min32chars`. Для production нужен .env файл или secrets management. Это очевидно для dev, но стоит добавить docker-compose.prod.yml.

**Нет health check endpoint для readiness vs liveness.** `/api/health` проверяет всё — и DB, и S3. Kubernetes требует разделения: liveness (процесс жив) и readiness (готов принимать трафик).

**Нет миграций как часть CI.** `prisma migrate deploy` выполняется в CMD Dockerfile — при ошибке миграции контейнер упадёт. Стоит разделить миграцию и запуск.

---

## 9. Качество кода

### Что хорошо

**Единообразие.** Все роуты следуют одному паттерну: `router.method(path, middleware[], asyncHandler(handler))`. Все сервисы — чистые async-функции. Маппинг через отдельные mapper-функции.

**Минимализм.** Нет over-engineering'а. Utility-файлы (`asyncHandler.ts` — 15 строк, `response.ts` — 19 строк, `password.ts` — 14 строк) делают ровно одну вещь. Нет абстракций ради абстракций.

**Хорошая обработка nullable-полей.** Selective update'ы через spread с проверкой `undefined`:
```typescript
...(data.title !== undefined && { title: data.title })
```

**Дефолты вынесены в `defaults.ts`** — единый источник правды, зеркалирующий schema.prisma `@default`.

### Замечания

**Дублирование маппинга.** `getBookById()` в books.service.ts и `exportUserConfig()` в exportImport.service.ts дублируют один и тот же маппинг BookDetail. Стоит извлечь в общую функцию.

**Magic strings.** Тема `'light'`/`'dark'` проверяется через строковые литералы в appearance.service.ts. Стоит использовать enum или const.

**Нет JSDoc на сервисных функциях** (кроме отдельных). Для библиотечного кода документация важна.

---

## 10. S3 / файловое хранилище

### Что хорошо

**Абстракция через утилиты** (`storage.ts`): `uploadFile`, `deleteFile`, `generateFileKey`, `extractKeyFromUrl` — чистые функции, легко заменить провайдера.

**UUID в ключах** (`generateFileKey`) — нет коллизий при конкурентных загрузках.

**Best-effort cleanup** при удалении книги (`books.service.ts:268-283`): `Promise.allSettled` + логирование orphaned URL'ов. Правильный паттерн — не блокировать DB-операцию из-за S3.

**`extractKeyFromUrl`** с корректным URL parsing и origin-проверкой — защита от SSRF через подменённый URL.

### Замечания

**Нет автоматической очистки orphaned файлов.** Если S3 cleanup при удалении книги не сработал, файлы остаются навсегда. Стоит добавить фоновый job для периодической очистки.

**Нет S3 presigned URLs.** Все файлы доступны по прямому публичному URL. Для приватного контента (главы книг, пользовательские шрифты) стоит использовать presigned URLs с ограниченным сроком.

**Нет content-type verification на уровне S3.** Файл загружается с клиентским content-type. Злоумышленник может загрузить HTML как `image/png` и получить XSS при прямом доступе к S3.

---

## 11. Зависимости

### Что хорошо

**Выбор зависимостей осмысленный:**
- Express 5 (latest), Prisma 6, bcrypt, passport, pino, zod, helmet — зрелые, поддерживаемые библиотеки.
- DOMPurify для санитизации — лучший выбор в экосистеме.
- `csrf-csrf` — современная альтернатива устаревшему `csurf`.

**Минимум зависимостей.** Нет лишнего — каждая библиотека решает конкретную задачу.

### Замечания

**`vitest: ^2.0.0` в server/package.json, но `vitest: ^4.0.18` в корневом package.json.** Несогласованность версий может привести к проблемам.

**Нет `@types/express@5`.** Express 5 имеет собственные типы, но `@types/express: ^5.0.0` может конфликтовать. Стоит проверить совместимость.

**Нет dependabot или renovate** для автоматических обновлений безопасности.

---

## 12. Итоговая таблица

| Аспект | Оценка | Комментарий |
|--------|--------|-------------|
| **Архитектура** | 8/10 | Чистое послойное разделение, но нет DI и repository layer |
| **Безопасность** | 9/10 | Впечатляющая проработка: session fixation, CSRF, account hijacking, XSS, SQL injection. Мелкие замечания по MIME и сессиям |
| **База данных** | 8/10 | Грамотная схема, индексы, транзакции. Нет soft delete, оптимистичной блокировки |
| **API Design** | 8/10 | RESTful, единообразный. Нет версионирования и ETag |
| **Обработка ошибок** | 9/10 | Эталонная реализация. Все типы ошибок обработаны, нет утечек |
| **Тестирование** | 7/10 | 99 кейсов, хорошая инфраструктура. Нет юнит-тестов, конкурентности, coverage |
| **Парсеры** | 8/10 | 5 форматов, сложная реализация DOC/EPUB. Нет error handling и timeout |
| **Инфраструктура** | 8/10 | Docker, multi-stage, healthcheck, graceful shutdown. Нет CI для бэкенда |
| **Качество кода** | 8.5/10 | Единообразный, минималистичный, читаемый. Минорное дублирование |
| **Хранилище файлов** | 7.5/10 | Абстракция и cleanup. Нет presigned URLs и orphan cleanup |

---

## 13. Рекомендации по приоритету

### Критические (P0)

1. **Добавить серверные тесты в CI/CD** — без этого регрессии неизбежны.
2. **Добавить timeout и error handling в парсеры книг** — malformed файлы могут повесить сервер.
3. **Убрать дублирование requireBookOwnership** в books.routes.ts (двойной запрос к БД).

### Важные (P1)

4. **Добавить юнит-тесты сервисов** — ускорит feedback loop и поймает баги в бизнес-логике.
5. **Добавить content-type verification по magic bytes** для загружаемых файлов.
6. **Добавить API versioning** (`/api/v1/`) до первого production-деплоя.
7. **Настроить test coverage** для серверных тестов.

### Желательные (P2)

8. Добавить connection pool настройки для Prisma.
9. Разделить health check на liveness и readiness.
10. Добавить cron job для очистки orphaned S3 файлов.
11. Рассмотреть presigned URLs для приватного контента.
12. Добавить rate limiting на health endpoint.

---

## Заключение

Бэкенд Flipbook — это **качественная, безопасная и хорошо структурированная серверная часть**. Автор демонстрирует глубокое понимание веб-безопасности (session fixation, CSRF, account hijacking, XSS), правильно работает с транзакциями и конкурентностью, и поддерживает высокий уровень единообразия кода.

Основные зоны роста — тестирование (юнит-тесты + CI) и операционная зрелость (versioning, presigned URLs, orphan cleanup). Это не критические проблемы, а естественные шаги эволюции от MVP к production-grade системе.

Для pet-проекта / портфолио — это **отличная работа**, демонстрирующая зрелый подход к бэкенд-разработке.
